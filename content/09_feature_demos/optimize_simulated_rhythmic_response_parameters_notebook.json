{
    "full_executed": false,
    "optimize_simulated_rhythmic_response_parameters_notebook.ipynb": {
        "7.9: Optimize simulated rhythmic response parameters": {
            "level": 1,
            "html": "<div class='markdown-cell'>\n    <h1>7.9: Optimize simulated rhythmic response parameters</h1>\n<p>This example demonstrates how to optimize the power spectral density\n(PSD) of a current dipole signal with significant alpha and beta\nspectral components.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # Authors: Carolina Fernandez <cxf418@miami.edu>\n\nimport matplotlib.pyplot as plt\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Let us import <code>hnn_core</code></p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        from hnn_core import (MPIBackend, jones_2009_model, simulate_dipole)\n\n# The number of cores may need modifying depending on your current machine.\nn_procs = 10\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>First, we define a function that will tell the optimization routine\nhow to modify the network drive parameters. The function will take in\nthe <a\nhref=\"https://jonescompneurolab.github.io/hnn-core/stable/generated/hnn_core.Network.html#hnn_core.Network\">Network</a>\nobject with no attached drives, and a dictionary of the parameters we\nwish to optimize.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        def set_params(net, params):\n\n    # Proximal (alpha)\n    weights_ampa_p = {'L2_pyramidal': params['alpha_prox_weight'],\n                      'L5_pyramidal': 4.4e-5}\n    syn_delays_p = {'L2_pyramidal': 0.1, 'L5_pyramidal': 1.}\n\n    net.add_bursty_drive('alpha_prox',\n                         tstart=params['alpha_prox_tstart'],\n                         burst_rate=params['alpha_prox_burst_rate'],\n                         burst_std=params['alpha_prox_burst_std'],\n                         numspikes=2,\n                         spike_isi=10,\n                         n_drive_cells=10,\n                         location='proximal',\n                         weights_ampa=weights_ampa_p,\n                         synaptic_delays=syn_delays_p)\n\n    # Distal (beta)\n    weights_ampa_d = {'L2_pyramidal': params['alpha_dist_weight'],\n                      'L5_pyramidal': 4.4e-5}\n    syn_delays_d = {'L2_pyramidal': 5., 'L5_pyramidal': 5.}\n\n    net.add_bursty_drive('alpha_dist',\n                         tstart=params['alpha_dist_tstart'],\n                         burst_rate=params['alpha_dist_burst_rate'],\n                         burst_std=params['alpha_dist_burst_std'],\n                         numspikes=2,\n                         spike_isi=10,\n                         n_drive_cells=10,\n                         location='distal',\n                         weights_ampa=weights_ampa_d,\n                         synaptic_delays=syn_delays_d)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Then, we define the constraints.</p>\n<p>The constraints must be a dictionary of tuples where the first value\nin each tuple is the lower bound and the second value is the upper bound\nfor the corresponding parameter.</p>\n<p>The following synaptic weight parameter ranges (units of\nmicro-siemens) were chosen so as to keep the model in physiologically\nrealistic regimes.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        constraints = dict()\nconstraints.update({'alpha_prox_weight': (4.4e-5, 6.4e-5),\n                    'alpha_prox_tstart': (45, 55),\n                    'alpha_prox_burst_rate': (1, 30),\n                    'alpha_prox_burst_std': (10, 30),\n                    'alpha_dist_weight': (4.4e-5, 6.4e-5),\n                    'alpha_dist_tstart': (45, 55),\n                    'alpha_dist_burst_rate': (1, 30),\n                    'alpha_dist_burst_std': (10, 30)})\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Now we define and fit the optimizer.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        from hnn_core.optimization import Optimizer\n\ntstop = 300\nscale_factor = 3000\nsmooth_window_len = 20\n\nnet = jones_2009_model()\noptim = Optimizer(net, tstop=tstop, constraints=constraints,\n                  set_params=set_params, obj_fun='maximize_psd')\n\n# 8-15 Hz (alpha) and 15-30 Hz (beta) are the frequency bands whose\n# power we wish to maximize in a ratio of 1 to 2.\nwith MPIBackend(n_procs=n_procs, mpi_cmd='mpiexec'):\n    optim.fit(f_bands=[(9, 11), (19, 21)], relative_bandpower=(1, 2),\n              scale_factor=scale_factor, smooth_window_len=smooth_window_len)\n    </code>\n</div>\n<div class='markdown-cell'>\n    <p>Finally, we can plot the optimized dipole, power spectral density\n(PSD), and convergence plot.</p>\n\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        from hnn_core.viz import plot_psd\n\nwith MPIBackend(n_procs=n_procs, mpi_cmd='mpiexec'):\n    opt_dpl = simulate_dipole(optim.net_, tstop=tstop, n_trials=1)[0]\nopt_dpl.scale(scale_factor)\nopt_dpl.smooth(smooth_window_len)\n\nfig, axes = plt.subplots(2, 1, figsize=(6, 6))\n\n# plot dipole\nopt_dpl.plot(ax=axes[0], layer='agg', show=False, color='tab:green')\naxes[0].legend(['optimized'])\n\n# plot psd\nplot_psd(opt_dpl, fmax=50, ax=axes[1], show=False)\nplt.show()\n    </code>\n</div>\n<div class='code-cell'>\n    <code class='language-python'>\n        # convergence\nfig1 = optim.plot_convergence(show=False)\nplt.show()\n    </code>\n</div>"
        }
    }
}